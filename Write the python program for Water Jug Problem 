from collections import deque

def water_jug_bfs(jug1, jug2, target):
    # To keep track of visited states
    visited = set()
    # Queue for BFS (state: (x, y), operations list)
    queue = deque([((0, 0), [])])  # both jugs empty initially

    while queue:
        (x, y), path = queue.popleft()

        # If we reached target, return path
        if x == target or y == target:
            return path + [(x, y)]

        if (x, y) in visited:
            continue
        visited.add((x, y))

        # Possible operations:
        next_states = [
            ((jug1, y), "Fill Jug1"),          # Fill jug1
            ((x, jug2), "Fill Jug2"),          # Fill jug2
            ((0, y), "Empty Jug1"),            # Empty jug1
            ((x, 0), "Empty Jug2"),            # Empty jug2
            ((x - min(x, jug2 - y), y + min(x, jug2 - y)), "Pour Jug1 -> Jug2"),  # Pour jug1→jug2
            ((x + min(y, jug1 - x), y - min(y, jug1 - x)), "Pour Jug2 -> Jug1")   # Pour jug2→jug1
        ]

        for (nx, ny), action in next_states:
            if (nx, ny) not in visited:
                queue.append(((nx, ny), path + [(x, y, action)]))

    return None  # No solution

# Example usage
if __name__ == "__main__":
    jug1_capacity = 4
    jug2_capacity = 3
    target = 2

    solution = water_jug_bfs(jug1_capacity, jug2_capacity, target)

    if solution:
        print("Steps to reach target:")
        for step in solution:
            print(step)
    else:
        print("No solution possible.")
