 
import heapq

class Node:
    def __init__(self, name, g=0, h=0, parent=None):
        self.name = name
        self.g = g  # cost so far
        self.h = h  # heuristic
        self.f = g + h
        self.parent = parent

    def __lt__(self, other):
        return self.f < other.f

def astar(graph, heuristics, start, goal):
    open_list = []
    closed_set = set()

    start_node = Node(start, g=0, h=heuristics[start])
    heapq.heappush(open_list, start_node)

    while open_list:
        current = heapq.heappop(open_list)

        if current.name == goal:
            path = []
            while current:
                path.append(current.name)
                current = current.parent
            return path[::-1]  # reverse path

        closed_set.add(current.name)

        for neighbor, cost in graph[current.name]:
            if neighbor in closed_set:
                continue
            g = current.g + cost
            h = heuristics[neighbor]
            neighbor_node = Node(neighbor, g, h, current)

            # Check if neighbor already in open list with lower f
            skip = False
            for n in open_list:
                if n.name == neighbor and n.f <= neighbor_node.f:
                    skip = True
                    break
            if not skip:
                heapq.heappush(open_list, neighbor_node)

    return None

# Example usage
if __name__ == "__main__":
    # Graph as adjacency list: (neighbor, cost)
    graph = {
        'A': [('B', 1), ('C', 3)],
        'B': [('D', 3), ('E', 1)],
        'C': [('F', 5)],
        'D': [('G', 2)],
        'E': [('G', 1)],
        'F': [('G', 2)],
        'G': []
    }

    # Heuristic values (straight-line distance estimates to G)
    heuristics = {
        'A': 7,
        'B': 6,
        'C': 5,
        'D': 4,
        'E': 2,
        'F': 3,
        'G': 0
    }

    path = astar(graph, heuristics, 'A', 'G')
    if path:
        print("Optimal Path:", " -> ".join(path))
    else:
        print("No path found.")
